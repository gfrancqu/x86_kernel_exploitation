/****************************************************
 * 
 * File Name 		:vulnModule.c
 * Created by		:Guillaume Francqueville
 * Creation date	:septembre 23th, 2016
 * Last changed by 	:Guillaume Francqueville
 * Last change 		:septembre 24th, 2016 15:09
 * Description		:module kernel vuln√©rable au buffer overflow, hak2g2 septembre2016
 *
****************************************************/

#include <linux/module.h>
#include <linux/version.h>
#include <linux/kernel.h>
#include <linux/types.h>
#include <linux/kdev_t.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/cdev.h>
#include <asm/uaccess.h>
#include <linux/slab.h> 
 
static dev_t first; // Global variable for the first device number
static struct cdev c_dev; // Global variable for the character device structure
static struct class *cl; // Global variable for the device class


static int yeah(void){
  printk(KERN_INFO "wow such vulnerability, much security, wow");
  return 0;
}

struct vuln_struct_s {
  int pointer;
  char buffer[64];
  ssize_t (*yeah_func)(void);
};
 
static struct vuln_struct_s vuln_struct;

static int my_open(struct inode *i, struct file *f)
{
  printk(KERN_INFO "VulnModule: open()\n");
  return 0;
}
 
static int my_close(struct inode *i, struct file *f)
{
  printk(KERN_INFO "VulnModule: close()\n");
  return 0;
}
 
static ssize_t my_read(struct file *f, char __user *buf, size_t len, loff_t *off)
{
  printk(KERN_INFO "VulnModule: read()\n");
  return (vuln_struct.yeah_func)();
}
 
static ssize_t my_write(struct file *f, const char __user *buf,size_t len, loff_t *off)
{
  char * bufk;
  
  printk(KERN_INFO "Driver: write()\n");

  bufk = kmalloc(len+1, GFP_DMA);

  if(bufk){
    if (copy_from_user(bufk, buf, len))
      return -EFAULT;
    bufk[len] = '\0';

    vuln_struct.buffer[vuln_struct.pointer++]=*((long long int *) bufk);
    /*    vuln_struct.buffer[vuln_struct.pointer++]=*((long long int *) bufk+1);
    vuln_struct.buffer[vuln_struct.pointer++]=*((long long int *) bufk+2);
    vuln_struct.buffer[vuln_struct.pointer++]=*((long long int *) bufk+3);
    */
  }
  
  kfree(bufk);
  return len;
 
}
 
static struct file_operations pugs_fops =
{
  .owner = THIS_MODULE,
  .open = my_open,
  .release = my_close,
  .read = my_read,
  .write = my_write
};
 
static int __init vuln_init(void) /* Constructor */
{
  printk(KERN_INFO "VulnModule init");
  vuln_struct.yeah_func = (void*)yeah;
  vuln_struct.pointer=0;
  if (alloc_chrdev_region(&first, 0, 1, "vuln") < 0)
  {
    return -1;
  }
  if ((cl = class_create(THIS_MODULE, "chardrv")) == NULL)
  {
    unregister_chrdev_region(first, 1);
    return -1;
  }
  if (device_create(cl, NULL, first, NULL, "vuln") == NULL)
  {
    printk(KERN_INFO "Vuln error");
    class_destroy(cl);
    unregister_chrdev_region(first, 1);
    return -1;
  }
  cdev_init(&c_dev, &pugs_fops);
  if (cdev_add(&c_dev, first, 1) == -1)
  {
    printk( KERN_INFO "cdev_add bad :(");
    device_destroy(cl, first);
    class_destroy(cl);
    unregister_chrdev_region(first, 1);
    return -1;
  }
  printk(KERN_INFO "<Major, Minor>: <%d, %d>\n", MAJOR(first), MINOR(first));
  return 0;
}
 
static void __exit vuln_exit(void) /* Destructor */
{
    unregister_chrdev_region(first, 3);
    printk(KERN_INFO "VulnModule bye bye");
}
 
module_init(vuln_init);
module_exit(vuln_exit);
 
MODULE_LICENSE("GPL");
MODULE_AUTHOR("guillaume francqueville");
MODULE_DESCRIPTION("Module kernel vulnerable au buffer overflow, hack2g2 sept 2016");
